% ответы на вопросы
\newpage
\section*{Ответы на вопросы}
\addcontentsline{toc}{section}{\tocsecindent{Ответы на вопросы}}
\begin{enumerate}
    \item \textbf{В какой части правила сформулировано знание? Это знание о чем, с формальной точки зрения?}\\
    Знание формулируется в правой части правила. Оно содержит в себе некую информацию, которая является истиной.
    
    \item \textbf{Что такое процедура?}\\
    Процедурой называется совокупность правил, заголовки которых имеют одно и то же имя и одну и ту же арность (местность), т.е. это совокупность правил, описывающих одно определенное отношение. Процедура описывает одно отношение, которое нельзя сформулировать одним предложением.
    
    \item \textbf{Сколько в БЗ  текущего задания процедур?}\\
    В БЗ текущего задания четыре процедуры.

    \item \textbf{Что такое пример терма, это частный случай терма, пример? Как строится пример?}\\
    Терм B называется примером терма $A$, если существует такая подстановка такая, что $B = A  \theta$.
    
    Терм C является общим примером $A, B$ если существует подстановки $\theta_1$ и $\theta_2$ такие что С$ С = A \theta_1$ и $C = B \theta_2$.
	
	Пример. Имеется БЗ, в которой есть факт g(1, a, b). Базе Знаний подаётся запрос g(x, y, z). Cистема находит общий пример и только тогда утверждение из Базы Знаний может считаться доказательством истинности.
	
	
    \item \textbf{Что такое наиболее общий пример?}\\
   	Терм $S$ называется более общим чем терм $Т$, если $T$ является примером $S$, а $S$ не является примером $T$. 
   	$S$ называется наиболее общим примером $T_1$ и $T_2$, если $S$ такой их общий пример, который является более общим по отношению к любому другому их примеру. 
    
    \item \textbf{Назначение и результат работы алгоритма унификации. Что значит двунаправленная передача параметров при работе алгоритма унификации, поясните на примере одного из случаев пункта  3.}\\
    Алгоритм встроен в систему и для своей работы использует три области памяти:
    \begin{itemize}
    	
    
    \item стек: хранит равенства, унификацию которых надо доказать;
    \item рабочее поле:  равенство вытащенное из стека, которое сейчас доказываем;
    \item результирующая ячейка памяти: накапливает наиболее общий унификатор;
    \item флаг - переменная 'неудача':  равна 1, если возникла тупиковая ситуация иначе 0.
	\end{itemize}
    \textbf{шаг:}
    \textbf{начало:} Сопоставляем $TТ_1$=$ТT_2$\\
    занести в стек $TТ_1$=$ТT_2$\\
    положить неудача=0\\
    пока стек не пуст – \textbf{цикл}:
    \begin{itemize}
    \item	считать из стека в рабочую область очередное равенство S=Т
    \item	обработать считанное по правилам:
    \begin{itemize}
    \item	если S и Т несовпадающие константы,			то неудача=1, и выход из цикла
    \item	если одинаковые константы					то следующий шаг цикла
    \item	если S переменная и Т терм содержащий S,		то неудача=1, и выход из цикла
    \item	если S переменная и Т терм НЕ содержащий S,	то отыскать в стеке и в результирующей ячейке все вхождения S и заменить на Т. Добавить в результирующую ячейку равенство S=Т.  Следующий шаг цикла
    \item	если S и Т составные термы с разными функторами или разными арностями, то неудача=1, выход из цикла
    \item	если S и Т составные термы с одинаковыми функторами и арностью: $S=f(s_1 s_2 .. s_m);$   $T=f(t_1 t_2 ... t_m),$  то занести в стек равенство $S_1=T_1, S_2=T_2 ... S_m=T_m.$
\end{itemize}
    \item	очистить рабочее поле
	\end{itemize}
    –  \textbf{конец цикла}
    
    \textbf{если} неудача = 1 то унификация невозможна
    \\ \textbf{если} неудача = 0 то унификация успешна, результирующая ячейка содержит наиболее общий унификатор
    \\ \textbf{конец.}
    
    Таким образом, с помощью алгоритма унификации происходит двунаправленная передача параметров процедурам. Например, из внешнего мира в программу для дальнейшего использования или из программы во внешний мир – значения интересующего нас параметра. 
    
    
    
    \item \textbf{В каком случае запускается механизм отката?}\\
    Для обоснования истинности вопроса, не всегда бывает возможным подобрать нужное знание в принципе, или не всегда это можно выполнить однозначно. Кроме этого, не очевиден принцип и алгоритм (последовательность перебора) выбора знания для использования. Часто при выборе знания  и человеку и системе необходимо оценить содержательный смысл – семантику утверждения, что на формальном уровне однозначно выполнить сложно. Следует заметить, что недетерминизм поиска ответа – это базовый принцип работы естественного, искусственного интеллекта и системы Prolog. Таким образом, в сложных ситуациях – при высокой степени неопределенности, и человек и система Prolog совершают ошибки. Для того, что бы такая ошибка выбора знания для системы Prolog была не критична, в систему встроен механизм отката (на момент последнего сделанного выбора) и отмена принятого решения (выполненной конкретизации).
    
    \item \textbf{Виды и назначение переменных в Prolog. Примеры из задания.  Почему использованы те или другие переменные (примеры из задания)?}\\
    Переменные начинаются с заглавной буквы или с символа подчёркивания и могут быть анонимными или именованными (анонимная переменная обозначается нижним подчеркивание). Говорят, что переменная может быть связана с некоторым значением или оставаться независимой. Именованные переменные уникальны в рамках одного предложения. Анонимная переменная уникальна всегда. Переменные предназначены для передачи значений «во времени и в пространстве».

\end{enumerate}

% ответ
%\\